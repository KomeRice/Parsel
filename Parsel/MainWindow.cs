using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Gtk;
using Pango;
using UI = Gtk.Builder.ObjectAttribute;
using Window = Gtk.Window;
// ReSharper disable FieldCanBeMadeReadOnly.Local

// Can be ignored because of Gtk generates UI elements
#pragma warning disable 414

namespace Parsel
{
	class MainWindow : Window
	{
		/// <summary>
		/// Holds all generated ByteRanges
		/// </summary>
		private static List<ByteRange> _byteRanges = new List<ByteRange>();

		/// <summary>
		/// Holds all root ByteRanges for exporting purposes
		/// </summary>
		private static List<ByteRange> _rootRanges = new List<ByteRange>();

		/// <summary>
		/// Highlight to put on raw trace
		/// </summary>
		private static readonly TextTag Highlight = new TextTag("Highlight")
		{
			Background = "#0000ff",
			Foreground = "white",
			Weight = Weight.Bold
		};

		[UI] private Button _buttonExport = null;
		[UI] private Button _buttonImport = null;
		[UI] private Button _buttonPickFile = null;
		[UI] private TreeView _displayTrace = null;
		[UI] private Label _labelPrompt = null;

		[UI] private TextView _printTrace = null;
		[UI] private TextBuffer _traceBuffer = null;
		[UI] private TreeStore _traceTree = null;

		public MainWindow() : this(new Builder("MainWindow.glade"))
		{
		}

		private MainWindow(Builder builder) : base(builder.GetObject("MainWindow").Handle)
		{
			builder.Autoconnect(this);
			
			_traceBuffer.TagTable.Add(Highlight);

			DeleteEvent += Window_DeleteEvent;
			_buttonPickFile.Clicked += FileClicked;
			_buttonImport.Clicked += ImportClicked;
			_buttonExport.Clicked += ExportClicked;
			_displayTrace.CursorChanged += TreeOnCursorChanged;
			_buttonPickFile.TooltipText = "Doit être au format texte et correctement formaté, seules les en-têtes Ethernet, IPv4, TCP et HTTP sont prises en charge.";
			_buttonImport.TooltipText = "Doit être correctement formaté, seules les en-têtes Ethernet, IPv4, TCP et HTTP sont prises en charge.";
			_buttonExport.TooltipText = "Ouvrez une trace avant de pouvoir exporter.";
		}

		private void Window_DeleteEvent(object sender, DeleteEventArgs a)
		{
			Application.Quit();
		}

		/// <summary>
		/// Analyzes and populates the window based on a formatted set of data
		/// </summary>
		/// <param name="formatted">Formatted packet</param>
		private void Analyze(IList<string> formatted)
		{
			// Remove previous file operations
			ByteRange.ResetCount();
			_displayTrace.Selection.UnselectAll();
			_traceTree.Clear();
			_traceBuffer.RemoveAllTags(_traceBuffer.StartIter, _traceBuffer.EndIter);
			_traceBuffer.Clear();
					
			_byteRanges.Clear();
			_rootRanges.Clear();
			_buttonExport.Sensitive = true;
			
			_printTrace.Buffer.Text = string.Join("\n", formatted);

			// Split file into packets 
			var packets = ParseUtils.ParseText(formatted).ToList();
			_byteRanges.AddRange(packets);
			// Parse packets and add to tree
			foreach (var packet in packets)
			{
				var root = _traceTree.AppendValues(packet.GetField(), packet.GetSize(), "",
					packet.GetId());
				_rootRanges.Add(packet);

				// Parse headers

				// Ethernet
				var ethernet = ParseUtils.ParseEthernet(packet, _traceBuffer.Text);
				packet.AddChild(ethernet);
				ModelHelper.AddChildren(ethernet, _traceTree, root, _byteRanges);

				var type = ethernet.GetChildren().Find(br => br.GetField() == "Type");
				if (type == null) continue;
				if (!type.GetValue().Contains("IPv4"))
				{
					var unknownType = new ByteRange(type.GetValue(), 0, 0, new List<byte>(),
						$"Type non supporté, reste du packet ignoré...");
					packet.AddChild(unknownType);
					ModelHelper.AddChildren(unknownType, _traceTree, root, _byteRanges);
					continue;
				};

				// Ip
				var ip = ParseUtils.ParseIp(packet, _traceBuffer.Text);
				packet.AddChild(ip);
				ModelHelper.AddChildren(ip, _traceTree, root, _byteRanges);

				var protocol = ip.GetChildren().Find(br => br.GetField() == "Protocol");
				if (protocol == null) continue;
						
				// Skip if not TCP 
				if (!protocol.GetValue().Contains("TCP"))
				{
					var unknownProtocol = new ByteRange(protocol.GetValue(), 0, 0, new List<byte>(),
						$"Protocol non supporté, reste du packet ignoré..."); 
					packet.AddChild(unknownProtocol);
					ModelHelper.AddChildren(unknownProtocol, _traceTree, root, _byteRanges);
					continue;
				}

				var byteOffsetTcp = ip.GetByteList().Count + ethernet.GetByteList().Count;
				var startIndexTcp = ip.GetRangeEnd();

				// Tcp

				var tcp = ParseUtils.ParseTcp(packet, _traceBuffer.Text, byteOffsetTcp, startIndexTcp);
				packet.AddChild(tcp);
				ModelHelper.AddChildren(tcp, _traceTree, root, _byteRanges);

				// HTTP
				var byteOffsetHttp = tcp.GetByteList().Count + byteOffsetTcp;
				var startIndexHttp = tcp.GetRangeEnd();
				var http = ParseUtils.ParseHttp(packet, _traceBuffer.Text, byteOffsetHttp, startIndexHttp);
				// If no http end of header indicator is found, skip
				if (http == null) continue;
				packet.AddChild(http);
				ModelHelper.AddChildren(http, _traceTree, root, _byteRanges);
			}

					
			_buttonExport.TooltipText = "Exporter au format JSON...";
					
			_labelPrompt.Text = "Analyser une autre trace...";
		}

		private void FileClicked(object sender, EventArgs a)
		{
			// Open File picker
			var fc = new FileChooserDialog("Choisir fichier à ouvrir", this, 
				FileChooserAction.Open, "Annuler", ResponseType.Cancel, "Ouvrir", ResponseType.Accept);

			// Filter to text files
			var filter = new FileFilter {Name = "Fichiers texte"};
			filter.AddPattern("*.txt");
			fc.Filter = filter;

			try
			{
				if (fc.Run() == (int) ResponseType.Accept)
				{
					// Read and format file
					var f = File.ReadAllText(fc.Filename);
					fc.Dispose();
					Analyze(ParseUtils.Format(f));
				}
				else
				{
					fc.Dispose();
				}
			}
			catch (Exception e)
			{
				_labelPrompt.Text =
					"Le fichier donné est invalide, corrompu ou contient des erreurs, la lecture peut contenir des erreurs.";
				Console.Error.WriteLine($"File contained error(s): {e.Message}");
				_buttonExport.TooltipText = "La lecture contient potentiellement des erreurs";
			}
		}

		private void ImportClicked(object sender, EventArgs a)
		{
			var impWin = new ImportDialog();
			try
			{
				if (impWin.Run() == (int) ResponseType.Accept)
				{
					Analyze(ParseUtils.Format(impWin.GetBufferText()));
					impWin.Dispose();
				}
				else
				{
					impWin.Dispose();
				}
			}
			catch (Exception e)
			{
				impWin.Dispose();
				_labelPrompt.Text =
					"Le texte donné est invalide, corrompu ou contient des erreurs, la lecture peut contenir des erreurs.";
				Console.Error.WriteLine($"Text contained error(s): {e.Message}");
				_buttonExport.TooltipText = "La lecture contient potentiellement des erreurs";
			}
		}

		private void ExportClicked(object sender, EventArgs a)
		{
			// Open file picker
			var fc = new FileChooserDialog("Enregistrer sous...", this,
				FileChooserAction.Save, "Annuler", ResponseType.Cancel, "Enregistrer", ResponseType.Accept);
			
			// Filter to json
			var filter = new FileFilter {Name = "Fichiers JSON"};
			filter.AddPattern("*.json");
			fc.Filter = filter;
			
			try
			{
				// If dialog is cancelled or closed, abort and return
				if (fc.Run() != (int) ResponseType.Accept)
				{
					fc.Dispose();
					return;
				}
				
				// Append .json to file name if it doesn't exist
				var path = fc.Filename.EndsWith(".json") ? fc.Filename : fc.Filename + ".json";
				fc.Dispose();
				
				// Write file and show success dialog
				var json = _rootRanges.Aggregate("", (current, packet) => current + packet.ToJson());
				File.WriteAllText(path, json);

				var messageDialog = new MessageDialog(this, DialogFlags.DestroyWithParent, MessageType.Info,
					ButtonsType.Ok, "Fichier enregistré") {Title = "Info"};
				messageDialog.Run();
				messageDialog.Dispose();
			}
			catch (Exception e)
			{
				var messageDialog = new MessageDialog(this, DialogFlags.DestroyWithParent, MessageType.Error,
					ButtonsType.Ok, $"Une erreur est survenue: {e.Message}") {Title = "Erreur"};
				messageDialog.Run();
				Console.Error.WriteLine(e);
			}
		}

		private void TreeOnCursorChanged(object sender, EventArgs e)
		{
			_traceBuffer.RemoveAllTags(_traceBuffer.StartIter, _traceBuffer.EndIter);
			
			var selection = (sender as TreeView)?.Selection;

			if (selection == null || !selection.GetSelected(out var model, out var iter)) return;
			var selectedId = Convert.ToInt32(model.GetValue(iter, 3).ToString());
			var selectedItem = _byteRanges.Find(b => b.GetId() == selectedId);
			if (selectedItem != null)
				ModelHelper.ByteHighlighter(selectedItem.GetRangeStart(), selectedItem.GetByteList().Count, Highlight,
					_traceBuffer);
		}
	}
}